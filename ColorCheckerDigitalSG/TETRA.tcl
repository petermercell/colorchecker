set cut_paste_input [stack 0]
version 16.0 v1
push $cut_paste_input
BlinkScript {
 recompileCount 1
 ProgramGroup 1
 KernelDescription "3 \"Tetra\" iterate pixelWise b802b7d1d991556e45f61f9173973b54b889c04ba28042e30725138691f2efce 2 \"src\" Read Point \"dst\" Write Point 7 \"red\" Float 3 AACAPwAAAAAAAAAAAAAAAA== \"grn\" Float 3 AAAAAAAAgD8AAAAAAAAAAA== \"blu\" Float 3 AAAAAAAAAAAAAIA/AAAAAA== \"cyn\" Float 3 AAAAAAAAgD8AAIA/AAAAAA== \"mag\" Float 3 AACAPwAAAAAAAIA/AAAAAA== \"yel\" Float 3 AACAPwAAgD8AAAAAAAAAAA== \"inv\" Bool 1 AA== 7 \"red\" 3 1 Default \"grn\" 3 1 Default \"blu\" 3 1 Default \"cyn\" 3 1 Default \"mag\" 3 1 Default \"yel\" 3 1 Default \"inv\" 1 1 Default 0"
 kernelSource "//TetraInterp v001 Feb 26, 2018 by Steve Yedlin\n//with help from Eric Cameron and Richard Goedeken\n \n//Tetrahedral interpolation is invertible IF the\n//cube corners are not turned inside out.\n//For example, as long as cyan is not greener than green.\nkernel Tetra : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n    Image<eWrite> dst; // the output image\n \n \n    param:\n        float3 red;\n        float3 grn;\n        float3 blu;\n        float3 cyn;\n        float3 mag;\n        float3 yel;\n        bool inv;\n \n    void define()\{\n        defineParam(red, \"red\", float3(1.f,0.f,0.f));\n        defineParam(grn, \"grn\", float3(0.f,1.f,0.f));\n        defineParam(blu, \"blu\", float3(0.f,0.f,1.f));\n        defineParam(cyn, \"cyn\", float3(0.f,1.f,1.f));\n        defineParam(mag, \"mag\", float3(1.f,0.f,1.f));\n        defineParam(yel, \"yel\", float3(1.f,1.f,0.f));\n    \}\n \n    float determinantMinor( int rowHeight, int columnWidth, float3x3 matrix)\n    \{\n \n        int y1 = rowHeight\t== 0 ? 1 : 0;\n        int y2 = rowHeight\t== 2 ? 1 : 2;\n \n        int x1 = columnWidth == 0 ? 1 : 0;\n        int x2 = columnWidth == 2 ? 1 : 2;\n \n        return (matrix\[y1]\[x1] * matrix\[y2]\[x2]) - (matrix\[y1]\[x2] * matrix\[y2]\[x1]);\n    \}\n \n    float determinant(float3x3 theMatrix)\n    \{\n        return (theMatrix\[0]\[0] * determinantMinor(0.f,0.f,theMatrix))\n        - (theMatrix\[0]\[1] * determinantMinor(0.f,1.f,theMatrix))\n        + (theMatrix\[0]\[2] * determinantMinor(0.f,2.f,theMatrix));\n    \}\n \n    float3x3 matrixInverse(float3x3 input)\n    \{\n        float det = determinant(input);\n\n        float3x3 output;\n         int x,y;\n         for (y = 0; y<3; y++)\n            for (x = 0; x<3; x++)\n            \{\n                output\[y]\[x] = determinantMinor(x,y,input) * (1.f / det);\n                if( 1 == ((x+y) % 2) )\n                    output\[y]\[x] = - output\[y]\[x];\n            \}\n        return output;\n    \}\n \n    //A function that returns the rotational distance of a point (around the gray diagonal) from red\n    float pt_ang(float3 triplet , float3 corners\[6])\{\n\t\t\n        float3 rc0 = corners\[0];  //red corner is the first in the array\n        float3 tr0 = triplet;\n        float eps = 1e-6; \t   //small nudge to avoid what seems to be precision errors..\n\n        //missing rotation..\n\tfloat a_ang = PI/4.f;\n        float3 tr1;\n        tr1.x = tr0.x;\n        tr1.y = tr0.y * cos(a_ang) + tr0.z * sin(a_ang);\n        tr1.z = tr0.y * (-sin(a_ang)) + tr0.z * cos(a_ang);\n        float3 rc1;\n        rc1.x = rc0.x;\n        rc1.y = rc0.y * cos(a_ang) + rc0.z * sin(a_ang);\n        rc1.z = rc0.y * (-sin(a_ang)) + rc0.z * cos(a_ang);\n\t\n        //rotate so that gray diagonal is vertical\t\n        float b_ang = atan2(sqrt(2),1.f)-PI/2.f;\n        float3 tr2;\n        tr2.x = tr1.x * cos(b_ang) + tr1.y * sin(b_ang);\n        tr2.y = tr1.x * (-sin(b_ang)) + tr1.y * cos(b_ang);\n        tr2.z = tr1.z;\n        float3 rc2;\n        rc2.x = rc1.x * cos(b_ang) + rc1.y * sin(b_ang);\n        rc2.y = rc1.x * (-sin(b_ang)) + rc1.y * cos(b_ang);\n        rc2.z = rc1.z;\n \n        //now rotate on the now-vertical gray axis so that red is at -pi rotation angle\n        float g_ang =  atan2(rc2.x,rc2.z) - PI;\n        float3 tr3;\n        tr3.x = tr2.x * cos(g_ang) + tr2.z * (-sin(g_ang));\n        tr3.y = tr2.y;\n        tr3.z = tr2.x * sin(g_ang) + tr2.z * cos(g_ang);\n        float3 rc3;\n        rc3.x = rc2.x * cos(g_ang) + rc2.z * (-sin(g_ang));\n        rc3.y = rc2.y;\n        rc3.z = rc2.x * sin(g_ang) + rc2.z * cos(g_ang);\n        \n        return atan2(tr3.x - eps, tr3.z);  //here's where epsilon is used\n    \}\n \n \n    //A function that finds which of the 6 tetrahedrons a point is contained in,\n    //even if the cube has been deformed\n    int tetra_region(float3 rgb, float3 corners\[6]) \{\n\n        float ang = pt_ang(rgb , corners);\n \n        float corner_angs\[6];\n        for (int i = 0; i < 6; i++)\{\n            corner_angs\[i] = pt_ang(corners\[i] , corners);\n        \}\n \n        int region = 5;\n        for (int i = 0; i < 5; i++) \{\n            if ( corner_angs\[i] <= ang && ang < corner_angs\[i+1] )\{\n                region = i;\n                break;\n            \}\n        \}\n \n        return region;\n \n    \}\n \n \n    float3 tetra( float3 triplet , float3 corners\[6])\{\n \n                float r = triplet.x;\n                float g = triplet.y;\n                float b = triplet.z;\n \n                float3 wht = float3(1.f,1.f,1.f);\n                float3 red = corners\[0];\n                float3 yel = corners\[1];\n                float3 grn = corners\[2];\n                float3 cyn = corners\[3];\n                float3 blu = corners\[4];\n                float3 mag = corners\[5];\n \n        if (r>g) \{\n            //r>g>b\n            if (g>b)\{\n                return r*red + g*(yel-red) + b*(wht-yel);\n            \}\n            //r>b>g\n            else if (r>b)\{\n                return r*red + g*(wht-mag) + b*(mag-red);\n            \}\n            //b>r>g\n            else\{\n                return r*(mag-blu) + g*(wht-mag) + b*blu;\n            \}\n\t\}\n        else \{\t\n\t  //b>g>r  \n            if (b>g)\{\n                return r*(wht-cyn) + g*(cyn-blu) + b*blu;\n            \}\n            //g>b>r\n            else if (b>r)\{\n                return r*(wht-cyn) + g*grn + b*(cyn-grn);\n            \}\n            //g>r>b\n            else\{\n                return r*(yel-grn) + g*grn + b*(wht-yel);\n            \}\n        \}\n    \}\n \n    float3 inv_tetra( float3 triplet , float3 corners\[6])\{\n \n        float r = triplet.x;\n        float g = triplet.y;\n        float b = triplet.z;\n \n        float3 wht = float3(1.f,1.f,1.f);\n        float3 red = corners\[0];\n        float3 yel = corners\[1];\n        float3 grn = corners\[2];\n        float3 cyn = corners\[3];\n        float3 blu = corners\[4];\n        float3 mag = corners\[5];\n \n \n        int region = tetra_region(triplet,corners);\n        float3 cR;\n        float3 cG;\n        float3 cB;\n \n        if (region == 0)\{\n            //r>g>b \n            cR = red;\n            cG = yel-red;\n            cB = wht-yel;\n        \}\n        else if (region == 1)\{\n            //g>r>b\n            cR = yel-grn;\n            cG = grn;\n            cB = wht-yel;\n        \}\n        else if (region == 2)\{\n            //g>b>r\n            cR = wht-cyn;\n            cG = grn;\n            cB = cyn-grn;\n        \}\n        else if (region == 3)\{\n\t  //b>g>r \n            cR = wht-cyn;\n            cG = cyn-blu;\n            cB = blu;\n        \}\n        else if (region == 4)\{\n            //b>r>g\n            cR = mag-blu;\n            cG = wht-mag;\n            cB = blu;\n        \}\n        else \{\n            //r>g>b\n            cR = red;\n            cG = wht-mag;\n            cB = mag-red;\n        \}\n \n \n        float3x3 matrix = float3x3(cR.x,cR.y,cR.z,cG.x,cG.y,cG.z,cB.x,cB.y,cB.z);\n        float3x3 inverse = matrixInverse(matrix);\n \n        cR.x = inverse\[0]\[0];\n        cR.y = inverse\[0]\[1];\n        cR.z = inverse\[0]\[2];\n \n        cG.x = inverse\[1]\[0];\n        cG.y = inverse\[1]\[1];\n        cG.z = inverse\[1]\[2];\n \n        cB.x = inverse\[2]\[0];\n        cB.y = inverse\[2]\[1];\n        cB.z = inverse\[2]\[2];\n \n        return (r * cR + g * cG + b * cB);\n \n    \}\n \n \n \n \n    void process() \{\n        // Read the input image\n \n        SampleType(src) input = src();\n \n        float3 rgb;\n        rgb.x = input.x;\n        rgb.y = input.y;\n        rgb.z = input.z;\n \n        float3 corners\[6];\n \n        corners\[0] = red;\n        corners\[1] = yel;\n        corners\[2] = grn;\n        corners\[3] = cyn;\n        corners\[4] = blu;\n        corners\[5] = mag;\n \n        float3 output = tetra( rgb , corners);\n        if (inv)\{\n            output = inv_tetra( rgb , corners);\n        \}\n \n \n        // Write the result to the output image\n        dst() = float4 ( output.x, output.y , output.z , input.w);\n \n    \}\n\};"
 rebuild ""
 rebuild_finalise ""
 name TETRA
 selected true
 xpos -60
 ypos -124
}
